#include "rtp_multicast_api.h"#include "rtpsession.h"#include "rtpsessionparams.h"#include "rtpudpv4transmitter.h"#include "rtpipv4address.h"#include "rtperrors.h"#include "rtppacket.h"using namespace jrtplib;using namespace std;#if 1#define debug_printf(fmt,arg...) do{if (1||strstr(__FILE__,"Cprasexml.cpp")==NULL){\				printf("[%s:%d]"fmt,__FILE__,__LINE__,##arg);}\			}while(0)#else#define debug_printf(fmt,arg...)#endifclass RTPMulticastSession : public RTPSession{protected:	void OnRTPPacket(RTPPacket *pack,const RTPTime &receivetime,const RTPAddress *senderaddress);	void OnRTCPCompoundPacket(RTCPCompoundPacket *pack,const RTPTime &receivetime, const RTPAddress *senderaddress);};void RTPMulticastSession::OnRTPPacket(RTPPacket *pack,const RTPTime &receivetime,const RTPAddress *senderaddress)  {  	return;}  void RTPMulticastSession::OnRTCPCompoundPacket(RTCPCompoundPacket *pack,const RTPTime &receivetime, const RTPAddress *senderaddress)  {  	RTCPPacket *rtcppack;		pack->GotoFirstPacket();		while ((rtcppack=pack->GetNextPacket())!=NULL) 	{		if (rtcppack->IsKnownFormat()) 		{			switch (rtcppack->GetPacketType()) 			{				case RTCPPacket::RR:					struct in_addr addr;					addr.s_addr=htonl(((RTPIPv4Address*)senderaddress)->GetIP());					debug_printf("RR from %s is no date:\n",inet_ntoa(addr));					break;				default:					break;			}		}	}		return;}  static RTPMulticastSession rtpMulticastSession[MAX_RTP_MULTICAST_ONLINE_NUM];static bool	rtpMulticastSessionFlag[MAX_RTP_MULTICAST_ONLINE_NUM];static pthread_t rtpMulticastRecvThread[MAX_RTP_MULTICAST_ONLINE_NUM]; static RTP_MULTICAST_RECVMSG_FUNC rtpMulticastRecvFunc[MAX_RTP_MULTICAST_ONLINE_NUM];signed int rtp_multicast_init(void){	int index = 0;	for (index = 0; index < MAX_RTP_MULTICAST_ONLINE_NUM; index++)	{		rtpMulticastSessionFlag[index] = RTP_MULTICAST_FALSE;		rtpMulticastRecvFunc[index] = NULL;	}		return RTP_MULTICAST_SUCCESS;}signed int rtp_multicast_deinit(void){	int index = 0;	for (index = 0; index < MAX_RTP_MULTICAST_ONLINE_NUM; index++)	{		if(rtpMulticastSessionFlag[index])		{			rtp_multicast_destory(index);		}	}		return RTP_MULTICAST_SUCCESS;}signed int rtp_multicast_addroute(const char *ipaddr, const char *netdevice){	char cmd[256];	if ((NULL == ipaddr) || (NULL == netdevice))	{		return RTP_MULTICAST_NULL;	}	sprintf(cmd,"route add %s dev %s", ipaddr, netdevice);	if (0 != system(cmd))	{		return RTP_MULTICAST_FAILURE;	}		return RTP_MULTICAST_SUCCESS;}signed int rtp_multicast_create(RTP_MULTICAST_TYPE type, int payloadtype, int port, const char *ipaddr,  int *rtphandle){	int ret = -1;	int index = 0;	RTPSessionParams sessionparams;	RTPTime miniInterval(1.0);	RTPUDPv4TransmissionParams transparams;    static int Creat_Flag = 0;		if ((NULL == ipaddr) || (NULL == rtphandle))	{		return RTP_MULTICAST_NULL;	}	    if(Creat_Flag == 1)    {        return 0;    }	for (index = 0; index < MAX_RTP_MULTICAST_ONLINE_NUM; index++)	{		if(!rtpMulticastSessionFlag[index])		{			break;		}	}	if ((index >= MAX_RTP_MULTICAST_ONLINE_NUM) || (port <= 0))	{		return RTP_MULTICAST_FAILURE;	}	sessionparams.SetOwnTimestampUnit(1.0 / 90000.0);;	sessionparams.SetMaximumPacketSize(65535);	sessionparams.SetSessionBandwidth(1024 * 1024 * 10);	/*10Mbps*/	sessionparams.SetSourceTimeoutMultiplier(10.0);	sessionparams.SetUsePollThread(true);	sessionparams.SetMinimumRTCPTransmissionInterval(miniInterval);	transparams.SetRTPSendBuffer(64*1024);	transparams.SetPortbase(port);    	ret = rtpMulticastSession[index].Create(sessionparams, &transparams);	if (0 != ret)	{		printf("Error(ret=%d):%s-%d Create!\n", ret,__FUNCTION__,__LINE__);		return RTP_MULTICAST_FAILURE;	}    	rtpMulticastSession[index].SetDefaultMark(false);	   	rtpMulticastSession[index].SetDefaultPayloadType(payloadtype);	rtpMulticastSession[index].SetDefaultTimestampIncrement(90000.0/25.0/3.0);	RTPIPv4Address desaddr(ntohl(inet_addr(ipaddr)), port);	if (RTP_MULTICAST_RECEIVE == type)	{		ret  = rtpMulticastSession[index].JoinMulticastGroup(desaddr);		if (0 != ret)		{			rtpMulticastSession[index].Destroy();			rtpMulticastSession[index].BYEDestroy(RTPTime(1, 0), 0, 0);			printf("Error:%s-%d AddDestination", __FUNCTION__,__LINE__);			return RTP_MULTICAST_FAILURE;		}	}		ret = rtpMulticastSession[index].AddDestination(desaddr);	if (0 != ret)	{		rtpMulticastSession[index].Destroy();		rtpMulticastSession[index].BYEDestroy(RTPTime(1, 0), 0, 0);		printf("Error:%s-%d AddDestination", __FUNCTION__,__LINE__);		return RTP_MULTICAST_FAILURE;	}	*rtphandle = index;	rtpMulticastSessionFlag[index] = RTP_MULTICAST_TRUE;		printf("creat rtp socket success! rtphandle:%d\n", index);		return RTP_MULTICAST_SUCCESS;}signed int rtp_multicast_destory(int rtphandle){	if ((rtphandle < 0) || (rtphandle >= MAX_RTP_MULTICAST_ONLINE_NUM))	{		return RTP_MULTICAST_FAILURE;	}		if (rtpMulticastSessionFlag[rtphandle])	{		rtpMulticastSession[rtphandle].Destroy();		rtpMulticastSession[rtphandle].BYEDestroy(RTPTime(1, 0), 0, 0);		rtpMulticastSessionFlag[rtphandle] = RTP_MULTICAST_FALSE;	}		return RTP_MULTICAST_SUCCESS;}signed int rtp_multicast_sendmsg(int rtphandle, const char *data, int datalen, int payloadtype){	int ret = -1;	struct timeval m_start;	struct timeval m_end;	long long m_timetotl;		if (NULL == data)	{		return RTP_MULTICAST_NULL;	}	if ((rtphandle < 0) || (rtphandle >= MAX_RTP_MULTICAST_ONLINE_NUM))	{		return RTP_MULTICAST_FAILURE;	}	if ((!rtpMulticastSessionFlag[rtphandle]) || (datalen < 0))	{		return RTP_MULTICAST_FAILURE;	}		gettimeofday(&m_start, NULL); 	RTPTime::Wait(RTPTime(0,50));	ret = rtpMulticastSession[rtphandle].SendPacket((void *)data, datalen, payloadtype, false, (90000/25/30));	if (0 != ret)	{		printf("Error(ret=%d):%s-%d SendPacket!\n", ret, __FUNCTION__,__LINE__);		return RTP_MULTICAST_FAILURE;	}	gettimeofday(&m_end, NULL); 	m_timetotl+=(m_end.tv_sec-m_start.tv_sec)*1000*1000+(m_end.tv_usec-m_start.tv_usec);	if (m_timetotl>1000*200) 	{		memset(&m_start,0,sizeof(m_start));		memset(&m_end,0,sizeof(m_end));		m_timetotl=0;		RTPTime::Wait(RTPTime(0,80));	}		return RTP_MULTICAST_SUCCESS;}signed int rtp_multicast_register_recvmsg_func(int rtphandle, RTP_MULTICAST_RECVMSG_FUNC recvfunc){	if ((rtphandle < 0) || (rtphandle >= MAX_RTP_MULTICAST_ONLINE_NUM))	{		return RTP_MULTICAST_FAILURE;	}	if (!rtpMulticastSessionFlag[rtphandle])	{		return RTP_MULTICAST_FAILURE;	}	rtpMulticastRecvFunc[rtphandle] = recvfunc;	return RTP_MULTICAST_SUCCESS;}signed int rtp_multicast_unregister_recvmsg_func(int rtphandle){	if ((rtphandle < 0) || (rtphandle >= MAX_RTP_MULTICAST_ONLINE_NUM))	{		return RTP_MULTICAST_FAILURE;	}	if (!rtpMulticastSessionFlag[rtphandle])	{		return RTP_MULTICAST_FAILURE;	}	rtpMulticastRecvFunc[rtphandle] = NULL; 		return RTP_MULTICAST_SUCCESS;}static void* rtp_multicast_recvmsg(void *args){	int rtphandle = -1;	RTPPacket *rtppack = NULL;	unsigned char *recvdata = NULL;	long recvsize = 0;		if (NULL == args)	{		return NULL;	}	rtphandle = *(int *)(args);	if ((rtphandle < 0) || (rtphandle >= MAX_RTP_MULTICAST_ONLINE_NUM))	{		return NULL;	}	if (!rtpMulticastSessionFlag[rtphandle])	{		return NULL;	}	while (1)	{		if(NULL == rtpMulticastRecvFunc[rtphandle]) 		{			break;		}				rtpMulticastSession[rtphandle].BeginDataAccess();		/*get data from frist source*/		if(rtpMulticastSession[rtphandle].GotoFirstSourceWithData())		{			while((rtppack = rtpMulticastSession[rtphandle].GetNextPacket()) != NULL)			{				recvsize = rtppack->GetPayloadLength();				recvdata = rtppack->GetPayloadData();								rtpMulticastRecvFunc[rtphandle](recvdata, recvsize);								rtpMulticastSession[rtphandle].DeletePacket(rtppack);  			}		}		/*get data from other source*/		while(rtpMulticastSession[rtphandle].GotoNextSourceWithData())		{			while((rtppack = rtpMulticastSession[rtphandle].GetNextPacket()) != NULL)			{				recvsize = rtppack->GetPayloadLength();				recvdata = rtppack->GetPayloadData();				rtpMulticastRecvFunc[rtphandle](recvdata, recvsize);								rtpMulticastSession[rtphandle].DeletePacket(rtppack);  			}		}		rtpMulticastSession[rtphandle].EndDataAccess();	}	return NULL;}signed int rtp_multicast_open_recvmsg(int rtphandle){    int ret = -1;	static int pthreadParams;		if ((rtphandle < 0) || (rtphandle >= MAX_RTP_MULTICAST_ONLINE_NUM))	{		return RTP_MULTICAST_FAILURE;	}	if (!rtpMulticastSessionFlag[rtphandle])	{		return RTP_MULTICAST_FAILURE;	}	pthreadParams = rtphandle;	    ret = pthread_create(&rtpMulticastRecvThread[rtphandle], NULL, rtp_multicast_recvmsg, (void *)&pthreadParams);    if (0 != ret)    {        return RTP_MULTICAST_FAILURE;    }	return RTP_MULTICAST_SUCCESS;}signed int rtp_multicast_close_recvmsg(int rtphandle){	int ret = 0;		if ((rtphandle < 0) || (rtphandle >= MAX_RTP_MULTICAST_ONLINE_NUM))	{		return RTP_MULTICAST_FAILURE;	}	if (!rtpMulticastSessionFlag[rtphandle])	{		return RTP_MULTICAST_FAILURE;	}	if (!pthread_join(rtpMulticastRecvThread[rtphandle], NULL))	{		ret = pthread_cancel(rtpMulticastRecvThread[rtphandle]);	}	rtp_multicast_unregister_recvmsg_func(rtphandle);	return ret;}